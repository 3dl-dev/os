#!/usr/bin/env python3
"""OS bootstrap and management CLI.

Manages the relationship between the OS, organizations, and projects.
See docs/bootstrap-config.md for the full spec.

Usage:
  os bootstrap <org-repo-path>   Register an org and generate derived configs
  os status                      Show what the OS knows
  os projects [--json]           List all projects across all orgs
  os sweep [--json] [--signals-only]  Cross-project scan: signals + P0/P1 beads
  os signal --type <type> --to <repo> "title"  Create a signal bead
  os inbox [--from <repo>] [--type <type>] [--json]  Check incoming signals
"""

import json
import os
import sys
from pathlib import Path

# ── Constants ──

OS_CONF = Path.home() / '.local' / 'share' / 'os' / 'os.conf'
OS_DIR = Path(__file__).resolve().parent.parent
VERSION_FILE = OS_DIR / 'VERSION'


# ── Minimal YAML Parser ──

def parse_os_yml(path):
    """Parse os.yml with a minimal YAML parser.

    Handles the nested structure we need without external deps.
    """
    content = path.read_text()
    lines = content.split('\n')

    result = {
        'org': {},
        'projects': {},
        'dashboard': {},
    }

    section = None
    subsection = None
    current_project = None
    current_review = None
    i = 0

    while i < len(lines):
        line = lines[i]
        stripped = line.strip()

        if not stripped or stripped.startswith('#'):
            i += 1
            continue

        indent = len(line) - len(line.lstrip())

        # Top-level sections
        if indent == 0 and stripped.endswith(':'):
            key = stripped[:-1]
            if key in ('org', 'projects', 'dashboard'):
                section = key
                subsection = None
                current_project = None
            i += 1
            continue

        if indent == 0 and ': ' in stripped:
            key, _, val = stripped.partition(':')
            key = key.strip()
            val = val.strip().strip("'\"")
            if key in ('org', 'projects', 'dashboard'):
                section = key
            i += 1
            continue

        # org fields
        if section == 'org' and indent >= 2:
            if ': ' in stripped:
                key, _, val = stripped.partition(':')
                result['org'][key.strip()] = val.strip().strip("'\"")

        # projects fields
        elif section == 'projects' and indent >= 2:
            if indent == 2 and stripped.endswith(':'):
                current_project = stripped[:-1].strip()
                result['projects'][current_project] = {}
            elif indent == 2 and ': ' in stripped and not stripped.startswith('-'):
                key, _, val = stripped.partition(':')
                current_project = key.strip()
                result['projects'][current_project] = {}
            elif indent >= 4 and current_project and ': ' in stripped:
                key, _, val = stripped.partition(':')
                result['projects'][current_project][key.strip()] = val.strip().strip("'\"")

        # dashboard fields
        elif section == 'dashboard' and indent >= 2:
            if stripped.startswith('repo:'):
                result['dashboard']['repo'] = stripped[5:].strip().strip("'\"")
            elif stripped.startswith('standalone-reviews:'):
                subsection = 'standalone-reviews'
                result['dashboard']['standalone-reviews'] = []
            elif subsection == 'standalone-reviews':
                if stripped.startswith('- path:'):
                    val = stripped[7:].strip().strip("'\"")
                    current_review = {'path': val, 'action': 'Review', 'agent': ''}
                    result['dashboard']['standalone-reviews'].append(current_review)
                elif stripped.startswith('action:') and current_review:
                    current_review['action'] = stripped[7:].strip().strip("'\"")
                elif stripped.startswith('agent:') and current_review:
                    current_review['agent'] = stripped[6:].strip().strip("'\"")

        i += 1

    return result


def resolve_path(raw, base_dir):
    """Resolve a path relative to a base directory, expanding ~."""
    expanded = os.path.expanduser(raw)
    p = Path(expanded)
    if not p.is_absolute():
        p = base_dir / p
    return p.resolve()


# ── os.conf Management ──

def read_os_conf():
    """Read os.conf. Returns dict of org_name -> repo_path."""
    orgs = {}
    if OS_CONF.exists():
        for line in OS_CONF.read_text().strip().split('\n'):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split(None, 1)
            if len(parts) == 2:
                orgs[parts[0]] = parts[1]
    return orgs


def write_os_conf(orgs):
    """Write os.conf."""
    OS_CONF.parent.mkdir(parents=True, exist_ok=True)
    lines = ['# OS organization registry (managed by os bootstrap)']
    for name, path in sorted(orgs.items()):
        lines.append(f'{name} {path}')
    OS_CONF.write_text('\n'.join(lines) + '\n')


# ── Dashboard Config Generation ──

def generate_dashboard_config(config, org_repo_path):
    """Generate dashboard-config.yml from os.yml."""
    org_name = config['org'].get('name', 'unknown')
    base_dir = org_repo_path.parent

    lines = [
        '# AUTO-GENERATED by os bootstrap — do not edit manually',
        f'# Source: {org_repo_path}/os.yml',
        '',
        'projects:',
    ]

    # Org repo itself
    lines.append(f'  {org_name}: {org_repo_path}')

    # All projects
    for proj_name, proj_cfg in config['projects'].items():
        proj_path = resolve_path(proj_cfg.get('path', f'~/projects/{proj_name}'), base_dir)
        lines.append(f'  {proj_name}: {proj_path}')

    lines.append('')

    # Dashboard repo
    dash_repo = config.get('dashboard', {}).get('repo', '')
    if dash_repo:
        dash_path = resolve_path(dash_repo, base_dir)
        lines.append(f'dashboard_repo: {dash_path}')
    lines.append(f'org_repo: {org_name}')
    lines.append('')

    # Standalone reviews
    reviews = config.get('dashboard', {}).get('standalone-reviews', [])
    if reviews:
        lines.append('standalone_review_docs:')
        for rev in reviews:
            lines.append(f'  - path: {rev["path"]}')
            lines.append(f'    action: {rev["action"]}')
            if rev.get('agent'):
                lines.append(f'    agent: {rev["agent"]}')

    return '\n'.join(lines) + '\n'


# ── Commands ──

def cmd_bootstrap(args):
    """Register an org and generate derived configs."""
    if not args:
        print('Usage: os bootstrap <org-repo-path>', file=sys.stderr)
        sys.exit(1)

    org_repo = Path(os.path.expanduser(args[0])).resolve()
    os_yml_path = org_repo / 'os.yml'

    if not os_yml_path.exists():
        print(f'Error: No os.yml found at {os_yml_path}', file=sys.stderr)
        sys.exit(1)

    print(f'Reading os.yml from {org_repo}...')
    config = parse_os_yml(os_yml_path)

    org_name = config['org'].get('name', 'unknown')
    org_display = config['org'].get('display', org_name)

    print(f'Org: {org_name} ({org_display})')
    print('Projects:')

    base_dir = org_repo.parent
    project_status = []
    for proj_name, proj_cfg in config['projects'].items():
        proj_path = resolve_path(proj_cfg.get('path', f'~/projects/{proj_name}'), base_dir)
        exists = proj_path.exists()
        status = 'exists' if exists else 'MISSING'
        mark = '\u2713' if exists else '\u2717'
        print(f'  {proj_name:16s} {proj_path}  {mark} {status}')
        project_status.append((proj_name, proj_path, exists))

    # Register in os.conf
    orgs = read_os_conf()
    orgs[org_name] = str(org_repo)
    write_os_conf(orgs)
    print(f'\nRegistered {org_name} in {OS_CONF}')

    # Generate dashboard config
    dash_config = generate_dashboard_config(config, org_repo)
    dash_config_path = OS_DIR / 'web' / 'dashboard-config.yml'
    dash_config_path.write_text(dash_config)
    print(f'Generated dashboard config at {dash_config_path}')

    existing = sum(1 for _, _, e in project_status if e)
    missing = len(project_status) - existing
    print(f'\nDone. The OS now knows about {org_name} and its {len(project_status)} projects ({existing} exist, {missing} missing).')


def cmd_status(args):
    """Show what the OS knows."""
    os_version = VERSION_FILE.read_text().strip() if VERSION_FILE.exists() else '?'
    print(f'OS: {OS_DIR} (v{os_version})')

    orgs = read_os_conf()
    print(f'Orgs: {len(orgs)}')

    if not orgs:
        print('\nNo organizations registered. Run: os bootstrap <org-repo-path>')
        return

    for org_name, org_path_str in orgs.items():
        org_path = Path(org_path_str)
        os_yml_path = org_path / 'os.yml'

        if not os_yml_path.exists():
            print(f'\n{org_name} ({org_path_str})')
            print(f'  Config: MISSING ({os_yml_path})')
            continue

        config = parse_os_yml(os_yml_path)
        display = config['org'].get('display', org_name)
        print(f'\n{org_name} ({display})')
        print(f'  Config: {os_yml_path}')

        base_dir = org_path.parent
        projects = config.get('projects', {})
        existing = 0
        for proj_name, proj_cfg in projects.items():
            proj_path = resolve_path(proj_cfg.get('path', f'~/projects/{proj_name}'), base_dir)
            exists = proj_path.exists()
            if exists:
                existing += 1

            # Check os-version alignment
            os_ver_file = proj_path / '.os-version'
            if os_ver_file.exists():
                proj_ver = os_ver_file.read_text().strip()
                if proj_ver == os_version:
                    ver_status = f'v{proj_ver} (aligned)'
                else:
                    ver_status = f'v{proj_ver} (outdated)'
            else:
                ver_status = 'v0 (no .os-version)'

            mark = '\u2713' if exists else '\u2717'
            print(f'    {proj_name:16s} {proj_path}  {mark} {ver_status}')

        missing = len(projects) - existing
        print(f'  Projects: {len(projects)} ({existing} exist, {missing} missing)')


def cmd_projects(args):
    """List all projects across all orgs."""
    as_json = '--json' in args
    orgs = read_os_conf()

    all_projects = []
    for org_name, org_path_str in orgs.items():
        org_path = Path(org_path_str)
        os_yml_path = org_path / 'os.yml'
        if not os_yml_path.exists():
            continue

        config = parse_os_yml(os_yml_path)
        base_dir = org_path.parent

        # Include org repo itself
        all_projects.append({
            'org': org_name,
            'name': org_name,
            'path': str(org_path),
            'prefix': config['org'].get('bead-prefix', org_name),
            'role': 'organization',
        })

        for proj_name, proj_cfg in config.get('projects', {}).items():
            proj_path = resolve_path(proj_cfg.get('path', f'~/projects/{proj_name}'), base_dir)
            all_projects.append({
                'org': org_name,
                'name': proj_name,
                'path': str(proj_path),
                'prefix': proj_cfg.get('bead-prefix', proj_name),
                'role': proj_cfg.get('role', 'project'),
            })

    if as_json:
        print(json.dumps(all_projects, indent=2))
    else:
        for p in all_projects:
            role_tag = f' [{p["role"]}]' if p['role'] != 'project' else ''
            print(f'{p["org"]}/{p["name"]:16s} {p["path"]}{role_tag}')


def _find_bd():
    """Find the bd binary."""
    import shutil
    bd = shutil.which('bd')
    if bd:
        return bd
    bd_path = OS_DIR / 'bin' / 'bd'
    if bd_path.exists():
        return str(bd_path)
    return None


def _get_beads(repo_path):
    """Get all beads from a repo as JSON."""
    import subprocess
    bd = _find_bd()
    if not bd:
        return []
    try:
        result = subprocess.run(
            [bd, 'list', '--json', '--no-daemon'],
            capture_output=True, text=True, cwd=str(repo_path), timeout=30
        )
        if result.returncode == 0 and result.stdout.strip():
            return json.loads(result.stdout)
    except (subprocess.TimeoutExpired, json.JSONDecodeError, FileNotFoundError):
        pass
    return []


def _get_all_projects():
    """Get all projects from all orgs (including org repos)."""
    orgs = read_os_conf()
    projects = []
    for org_name, org_path_str in orgs.items():
        org_path = Path(org_path_str)
        os_yml_path = org_path / 'os.yml'
        if not os_yml_path.exists():
            continue

        config = parse_os_yml(os_yml_path)
        base_dir = org_path.parent

        # Org repo itself
        projects.append({
            'org': org_name,
            'name': org_name,
            'path': org_path,
            'prefix': config['org'].get('bead-prefix', org_name),
            'role': 'organization',
        })

        for proj_name, proj_cfg in config.get('projects', {}).items():
            proj_path = resolve_path(proj_cfg.get('path', f'~/projects/{proj_name}'), base_dir)
            projects.append({
                'org': org_name,
                'name': proj_name,
                'path': proj_path,
                'prefix': proj_cfg.get('bead-prefix', proj_name),
                'role': proj_cfg.get('role', 'project'),
            })

    return projects


def cmd_sweep(args):
    """Cross-project sweep: find signals, high-priority beads, stale items."""
    as_json = '--json' in args
    signals_only = '--signals-only' in args

    projects = _get_all_projects()
    if not projects:
        print('No projects registered. Run: os bootstrap <org-repo-path>')
        return

    all_signals = []
    all_high_pri = []
    all_stale = []

    for proj in projects:
        repo_path = proj['path']
        if not repo_path.exists():
            continue

        beads = _get_beads(repo_path)
        open_beads = [b for b in beads if b.get('status') == 'open']

        for b in open_beads:
            title = b.get('title', '')
            priority = b.get('priority', 99)
            bead_id = b.get('id', '')

            # Staff signals
            if title.startswith('STAFF-SIGNAL:') or title.startswith('SIGNAL('):
                all_signals.append({
                    'repo': proj['name'],
                    'id': bead_id,
                    'title': title,
                    'priority': priority,
                    'created': b.get('created_at', b.get('created', ''))[:10],
                    'type': 'signal',
                })

            # High priority (P0/P1) — not signals
            elif priority <= 1 and not signals_only:
                all_high_pri.append({
                    'repo': proj['name'],
                    'id': bead_id,
                    'title': title,
                    'priority': priority,
                    'created': b.get('created_at', b.get('created', ''))[:10],
                    'type': 'high-pri',
                })

    # Sort
    all_signals.sort(key=lambda x: (x['priority'], x['created']))
    all_high_pri.sort(key=lambda x: (x['priority'], x['created']))

    if as_json:
        print(json.dumps({
            'signals': all_signals,
            'high_priority': all_high_pri,
        }, indent=2))
        return

    # Human-readable output
    if all_signals:
        print(f'Signals ({len(all_signals)}):')
        for s in all_signals:
            print(f'  P{s["priority"]} {s["repo"]}/{s["id"]:16s} {s["title"]}')
    else:
        print('No pending signals.')

    if not signals_only:
        print()
        if all_high_pri:
            print(f'High Priority P0/P1 ({len(all_high_pri)}):')
            for h in all_high_pri:
                print(f'  P{h["priority"]} {h["repo"]}/{h["id"]:16s} {h["title"]}')
        else:
            print('No high-priority open beads.')

    total = len(all_signals) + len(all_high_pri)
    print(f'\nScanned {len(projects)} repos. {total} items found.')


def cmd_signal(args):
    """Create a signal bead in the current repo."""
    import subprocess

    # Parse args
    signal_type = None
    to_repos = []
    priority = 2
    route_agent = None
    route_tier = None
    context_refs = []
    title_parts = []

    i = 0
    while i < len(args):
        if args[i] == '--type' and i + 1 < len(args):
            signal_type = args[i + 1]
            i += 2
        elif args[i] == '--to' and i + 1 < len(args):
            to_repos = [r.strip() for r in args[i + 1].split(',')]
            i += 2
        elif args[i] == '-p' and i + 1 < len(args):
            priority = int(args[i + 1])
            i += 2
        elif args[i] == '--route' and i + 1 < len(args):
            parts = args[i + 1].split(':')
            route_agent = parts[0]
            route_tier = parts[1] if len(parts) > 1 else None
            i += 2
        elif args[i] == '--context' and i + 1 < len(args):
            context_refs = [r.strip() for r in args[i + 1].split(',')]
            i += 2
        else:
            title_parts.append(args[i])
            i += 1

    title = ' '.join(title_parts)

    if not signal_type:
        print('Error: --type required (staff-signal, request, notify, query)', file=sys.stderr)
        sys.exit(1)
    if not to_repos:
        print('Error: --to required (target repo name)', file=sys.stderr)
        sys.exit(1)
    if not title:
        print('Error: signal title required', file=sys.stderr)
        sys.exit(1)

    valid_types = ('staff-signal', 'request', 'notify', 'query')
    if signal_type not in valid_types:
        print(f'Error: --type must be one of: {", ".join(valid_types)}', file=sys.stderr)
        sys.exit(1)

    # Detect current repo name
    try:
        result = subprocess.run(
            ['git', 'rev-parse', '--show-toplevel'],
            capture_output=True, text=True, timeout=5
        )
        from_repo = Path(result.stdout.strip()).name
    except Exception:
        from_repo = 'unknown'

    # Build bd create command
    full_title = f'SIGNAL({signal_type}): {title}'
    labels = f'signal,signal:{signal_type}'
    for repo in to_repos:
        labels += f',to:{repo}'

    # Build description with signal metadata
    desc_parts = [f'## Signal: {signal_type}']
    desc_parts.append(f'**From**: {from_repo}  **To**: {", ".join(to_repos)}')
    if route_agent:
        routing_str = route_agent
        if route_tier:
            routing_str += f' ({route_tier})'
        desc_parts.append(f'**Routing**: {routing_str}')
    desc_parts.append('')
    desc_parts.append(title)
    if context_refs:
        desc_parts.append('')
        desc_parts.append('**Context**:')
        for ref in context_refs:
            desc_parts.append(f'- {ref}')

    description = '\n'.join(desc_parts)

    bd = _find_bd()
    if not bd:
        print('Error: bd not found', file=sys.stderr)
        sys.exit(1)

    cmd = [
        bd, 'create', full_title,
        '-p', str(priority),
        '-l', labels,
        '-d', description,
        '--no-daemon',
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode == 0:
        print(result.stdout.strip())
    else:
        print(f'Error creating signal: {result.stderr.strip()}', file=sys.stderr)
        sys.exit(1)


def cmd_inbox(args):
    """Check incoming signals addressed to the current repo."""
    import subprocess

    # Detect current repo name
    try:
        result = subprocess.run(
            ['git', 'rev-parse', '--show-toplevel'],
            capture_output=True, text=True, timeout=5
        )
        my_repo = Path(result.stdout.strip()).name
    except Exception:
        print('Error: not in a git repo', file=sys.stderr)
        sys.exit(1)

    as_json = '--json' in args
    from_filter = None
    type_filter = None

    i = 0
    while i < len(args):
        if args[i] == '--from' and i + 1 < len(args):
            from_filter = args[i + 1]
            i += 2
        elif args[i] == '--type' and i + 1 < len(args):
            type_filter = args[i + 1]
            i += 2
        else:
            i += 1

    projects = _get_all_projects()
    inbox_items = []

    for proj in projects:
        repo_path = proj['path']
        repo_name = proj['name']

        if not repo_path.exists():
            continue
        if from_filter and repo_name != from_filter:
            continue
        if repo_name == my_repo:
            continue  # Don't scan self

        beads = _get_beads(repo_path)
        for b in beads:
            if b.get('status') == 'closed':
                continue
            labels = b.get('labels') or []
            if 'signal' not in labels:
                continue
            if f'to:{my_repo}' not in labels:
                continue

            # Extract signal type from labels
            sig_type = 'unknown'
            for l in labels:
                if l.startswith('signal:') and l != 'signal':
                    sig_type = l.split(':', 1)[1]

            if type_filter and sig_type != type_filter:
                continue

            inbox_items.append({
                'from': repo_name,
                'id': b.get('id', ''),
                'priority': b.get('priority', 99),
                'type': sig_type,
                'title': b.get('title', ''),
                'created': b.get('created_at', b.get('created', ''))[:10],
            })

    inbox_items.sort(key=lambda x: (x['priority'], x['created']))

    if as_json:
        print(json.dumps(inbox_items, indent=2))
        return

    if not inbox_items:
        print(f'No incoming signals for {my_repo}.')
        return

    print(f'Inbox for {my_repo} ({len(inbox_items)} signals):')
    print(f'{"FROM":8s} {"ID":18s} {"P":2s} {"TYPE":14s} TITLE')
    for item in inbox_items:
        print(f'{item["from"]:8s} {item["id"]:18s} {item["priority"]:1d}  {item["type"]:14s} {item["title"]}')


def cmd_help(args):
    """Print usage."""
    print(__doc__.strip())


# ── Main ──

COMMANDS = {
    'bootstrap': cmd_bootstrap,
    'status': cmd_status,
    'projects': cmd_projects,
    'sweep': cmd_sweep,
    'signal': cmd_signal,
    'inbox': cmd_inbox,
    'help': cmd_help,
    '--help': cmd_help,
    '-h': cmd_help,
}


def main():
    if len(sys.argv) < 2:
        cmd_help([])
        sys.exit(1)

    cmd = sys.argv[1]
    if cmd not in COMMANDS:
        print(f'Unknown command: {cmd}', file=sys.stderr)
        cmd_help([])
        sys.exit(1)

    COMMANDS[cmd](sys.argv[2:])


if __name__ == '__main__':
    main()
